static const char *fragment_shader_anop =
    "#version 100\n"
    "#extension GL_OES_EGL_image_external : require\n"
    "precision mediump float;\n"
    "varying vec2 TexCoord0;\n"
    "uniform samplerExternalOES sTexture;\n"
    "uniform mat4 uSTMatrix;\n"
    "uniform int render_type;    // 0: SDR, 1: HDR10, 2: HLG, 3: DoviP5, 4: VLC_HDR10, 5 VLC_HLG\n"
    "\n"
    "float max3(float a, float b, float c) {\n"
    "    return max(max(a, b), c);\n"
    "}\n"
    "\n"
    "const float ARIB_B67_A = 0.17883277;\n"
    "const float ARIB_B67_B = 0.28466892;\n"
    "const float ARIB_B67_C = 0.55991073;\n"
    "float arib_b67_inverse_oetf(float x_in) {\n"
    "    float x = max(x_in, 0.0);\n"
    "    if (x <= 0.5) {\n"
    "        x = (x * x) * (1.0 / 3.0);\n"
    "    } else {\n"
    "        x = (exp((x - ARIB_B67_C) / ARIB_B67_A) + ARIB_B67_B) / 12.0;\n"
    "    }\n"
    "    return x;\n"
    "}\n"
    "\n"
    "float ootf_1_2(float x) {\n"
    "    return x < 0.0 ? x : pow(x, 1.2);\n"
    "}\n"
    "\n"
    "float arib_b67_eotf(float x) {\n"
    "    return ootf_1_2(arib_b67_inverse_oetf(x));\n"
    "}\n"
    "\n"
    "const float ST2084_M1 = 0.1593017578125;\n"
    "const float ST2084_M2 = 78.84375;\n"
    "const float ST2084_C1 = 0.8359375;\n"
    "const float ST2084_C2 = 18.8515625;\n"
    "const float ST2084_C3 = 18.6875;\n"
    "const float XX_FLT_MIN = 1.17549435082228750797e-38;\n"
    "float st_2084_eotf(float x) {\n"
    "    float xpow = pow(x, 1.0 / ST2084_M2);\n"
    "    float num = max(xpow - ST2084_C1, 0.0);\n"
    "    float den = max(ST2084_C2 - ST2084_C3 * xpow, XX_FLT_MIN);\n"
    "    return pow(num / den, 1.0 / ST2084_M1);\n"
    "}\n"
    "\n"
    "float hable_standard(float value) {\n"
    "    float a = 0.15, b = 0.50, c = 0.10, d = 0.20, e = 0.02, f = 0.30;\n"
    "    return (value * (value * a + b * c) + d * e) / (value * (value * a + b) + d * f) - e / f;\n"
    "}\n"
    "\n"
    "float hable_darkness(float value) {\n"
    "    float a = 2.0, b = 0.50, c = 0.10, d = 0.00001, e = 0.03, f = 0.30;\n"
    "    return (value * (value * a + b * c) + d * e) / (value * (value * a + b) + d * f) - e / f;\n"
    "}\n"
    "\n"
    "float tone_mapping_standard(float value) {\n"
    "    float peak = 500.0 / 100.0;\n"
    "    return hable_standard(value) / hable_standard(peak);\n"
    "}\n"
    "\n"
    "float tone_mapping_darkness(float value, float threshold) {\n"
    "    if (value <= threshold) {\n"
    "        return hable_darkness(value);\n"
    "    } else {\n"
    "        float baseline1 = hable_darkness(threshold);\n"
    "        float baseline2 = tone_mapping_standard(threshold);\n"
    "        float baseline_delta = baseline1 - baseline2;\n"
    "        return tone_mapping_standard(value) + baseline_delta;\n"
    "    }\n"
    "}\n"
    "\n"
    "vec4 hdr_to_sdr(vec4 color, int render_type) {\n"
    "    float peak_luminance = 100.0;\n"
    "    float hlg_peak_luminance = 1000.0;\n"
    "    float st2084_peak_luminance = 10000.0;\n"
    "\n"
    "    vec3 fragColor;\n"
    "    if (render_type == 1 || render_type == 3) {\n"
    "        float scale = st2084_peak_luminance / peak_luminance;\n"
    "        fragColor = scale * vec3(st_2084_eotf(color.r), st_2084_eotf(color.g), st_2084_eotf(color.b));\n"
    "    } else if (render_type == 2) {\n"
    "        float scale = hlg_peak_luminance / peak_luminance;\n"
    "        fragColor = scale * vec3(arib_b67_eotf(color.r), arib_b67_eotf(color.g), arib_b67_eotf(color.b));\n"
    "    }\n"
    "\n"
    "    // const mat3 rgb2xyz2020 = mat3(vec3(0.6370, 0.1446, 0.1689),\n"
    "    //                               vec3(0.2627, 0.6780, 0.0593),\n"
    "    //                               vec3(0.0000, 0.0281, 1.0610));\n"
    "    // const mat3 xyz2rgb709 = mat3(vec3(3.2410, -1.5374, -0.4986),\n"
    "    //                              vec3(-0.9692, 1.8760, 0.0416),\n"
    "    //                              vec3(0.0556, -0.2040, 1.0570));\n"
    "    // fragColor *= rgb2xyz2020 * xyz2rgb709;\n"
    "\n"
    "    if (render_type == 3) {\n"
    "        const mat3 dovi_lms2rgb = mat3(vec3(3.06441879, -2.16597676, 0.10155818),\n"
    "                                       vec3(-0.65612108, 1.78554118, -0.12943749),\n"
    "                                       vec3(0.01736321, -0.04725154, 1.03004253));\n"
    "        const mat3 dovi_linear = mat3(vec3(1.0425415, -0.0213012695, -0.0213012695),\n"
    "                                      vec3(-0.0213012695, 1.0425415, -0.0213012695),\n"
    "                                      vec3(-0.0213012695, -0.0213012695, 1.0425415));\n"
    "        fragColor *= dovi_lms2rgb * dovi_linear;\n"
    "    }\n"
    "\n"
    "    float maxLuminance = max(max3(fragColor.r, fragColor.g, fragColor.b), 1e-6);\n"
    "    float mappedLuminance = maxLuminance;\n"
    "    if (render_type == 1) {\n"
    "        mappedLuminance = tone_mapping_darkness(maxLuminance, 0.006);\n"
    "    } else if (render_type == 2) {\n"
    "        mappedLuminance = tone_mapping_standard(maxLuminance);\n"
    "    } else if (render_type == 3) {\n"
    "        mappedLuminance = tone_mapping_darkness(maxLuminance, 0.1);\n"
    "    }\n"
    "    float scale = mappedLuminance / maxLuminance;\n"
    "    fragColor *= scale;\n"
    "\n"
    "    fragColor = max(fragColor, 0.0);\n"
    "    fragColor = pow(fragColor, vec3(1.0 / 2.2));\n"
    "\n"
    "    // float gray = dot(fragColor, vec3(0.299, 0.587, 0.114));\n"
    "    // fragColor = mix(vec3(gray), fragColor, 0.8);\n"
    "\n"
    "    return vec4(fragColor, 1.0);\n"
    "}\n"
    "\n"
    "float vlc_hable(float x)\n"
    "{\n"
    "    return ((x * (0.150000 * x + 0.050000) + 0.004000) / (x * (0.150000 * x + 0.500000) + 0.060000)) - 0.066667;\n"
    "}\n"
    "\n"
    "vec4 vlc_hdr10_to_sdr(vec4 color)\n"
    "{\n"
    "    const mat3 matrix = mat3(1.660497, -0.124547, -0.018154, -0.587657, 1.132895, -0.1005979, -0.072840, -0.008348, 1.118751);\n"
    "    color.rgb = max(color.rgb, 0.0);\n"
    "    color.rgb = pow(color.rgb, vec3(1.0 / 78.843750));\n"
    "    color.rgb = max(color.rgb - vec3(0.835938), 0.0) / (vec3(18.851562) - vec3(18.687500) * color.rgb);\n"
    "    color.rgb = pow(color.rgb, vec3(1.0 / 0.159302));\n"
    "    color.rgb *= vec3(100.000000);\n"
    "    color.rgb = matrix * color.rgb;\n"
    "    float sig = max(max(color.r, color.g), color.b);\n"
    "    float sig_peak = 100.000000;\n"
    "    float sig_avg = 0.250000;\n"
    "    float luma = dot(vec3(0.212637, 0.715183, 0.072180), color.rgb);\n"
    "    float coeff = max(sig - 0.18, 1e-6) / max(sig, 1e-6);\n"
    "    coeff = pow(coeff, 20.000000);\n"
    "    color.rgb = mix(color.rgb, vec3(luma), coeff);\n"
    "    sig = mix(sig, luma, coeff);\n"
    "    float sig_orig = sig;\n"
    "    float slope = min(1.0, 0.250000 / sig_avg);\n"
    "    sig *= slope;\n"
    "    sig_peak *= slope;\n"
    "    sig = vlc_hable(sig) / vlc_hable(sig_peak);\n"
    "    sig = min(sig, 1.0);\n"
    "    color.rgb *= sig / sig_orig;\n"
    "    color.rgb = max(color.rgb, 0.0);\n"
    "    color.rgb = pow(color.rgb, vec3(1.0 / 2.2));\n"
    "    return color;\n"
    "}\n"
    "\n"
    "vec4 vlc_hlg_to_sdr(vec4 color)\n"
    "{\n"
    "    const mat3 matrix = mat3(1.660497, -0.124547, -0.018154, -0.587657, 1.132895, -0.1005979, -0.072840, -0.008348, 1.118751);\n"
    "    color.rgb = max(color.rgb, 0.0);\n"
    "    color.rgb = mix(vec3(4.0) * color.rgb * color.rgb,\n"
    "                    exp((color.rgb - vec3(0.559911)) * vec3(1.0 / 0.178833)) + vec3(0.284669),\n"
    "                    vec3(lessThan(vec3(0.5), color.rgb)));\n"
    "    color.rgb = max(color.rgb, 0.0);\n"
    "    color.rgb *= vec3(0.506970 * pow(dot(vec3(0.262698, 0.678009, 0.059293), color.rgb), 0.2));\n"
    "    color.rgb = matrix * color.rgb;\n"
    "    float sig = max(max(color.r, color.g), color.b);\n"
    "    float sig_peak = 12.000000;\n"
    "    float sig_avg = 0.250000;\n"
    "    float luma = dot(vec3(0.212637, 0.715183, 0.072180), color.rgb);\n"
    "    float coeff = max(sig - 0.18, 1e-6) / max(sig, 1e-6);\n"
    "    coeff = pow(coeff, 20.000000);\n"
    "    color.rgb = mix(color.rgb, vec3(luma), coeff);\n"
    "    sig = mix(sig, luma, coeff);\n"
    "    float sig_orig = sig;\n"
    "    float slope = min(1.0, 0.250000 / sig_avg);\n"
    "    sig *= slope;\n"
    "    sig_peak *= slope;\n"
    "    sig = vlc_hable(sig) / vlc_hable(sig_peak);\n"
    "    sig = min(sig, 1.0);\n"
    "    color.rgb *= sig / sig_orig;\n"
    "    color.rgb = max(color.rgb, 0.0);\n"
    "    color.rgb = pow(color.rgb, vec3(1.0 / 2.2));\n"
    "    return color;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    vec4 color = texture2D(sTexture, (uSTMatrix * vec4(TexCoord0, 1, 1)).xy).rgba;\n"
    "    if (render_type >= 1 && render_type <= 3) {\n"
    "        color = hdr_to_sdr(color, render_type);\n"
    "    } else if (render_type == 4) {\n"
    "        color = vlc_hdr10_to_sdr(color);\n"
    "    } else if (render_type == 5) {\n"
    "        color = vlc_hlg_to_sdr(color);\n"
    "    }\n"
    "    gl_FragColor = color;\n"
    "}\n"
;
